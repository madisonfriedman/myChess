This folder contains a working copy of the files required to run my chess engine through the gui.
Some of the files here are used, some are not, and I haven't gotten around to pruning those out or refactoring
the rest of the files so this represents a very bare bones repository with limited explanation. I didn't write
the code for readability as I was the only one who needed/wanted to interact with/understand the code. Furthermore
the overall structure of the engine was changing frequently as my understanding of the nuances of the problem evolved.
This made commenting everything a pain as I had to test mutiple combinations of various segments of the code in order
to find an optimal combination. Had I realized at the start of this project how complex the code would be I probably
would have opted to take advantage of git from the start. Lesson learned, I can assure you that my production code
doesn't look as messy as this does at the moment. I plan to refactor everything when I have completed updating and
tuning the heuristic.

In order to runmy chess engine locally you will need these files:

1. ChessBoardWithColumnsAndRows.java
2. bitBoardOperations.java
3. AIv2Tree.java
4. chessPics.png
5. and all of the comparator classes. 

File 1 contains the basic GUI and this file needs to be executed to initiate the GUI. Everything else is called
via interaction with the GUI. 
File 2 contains all of the bitboard operations I required.
File 3 contains the tree and node classes along with relevant functions. 
File 4 contains the images for the GUI
The File 5 classes are simple comparator classes used when sorting the branches during AB search.



Description:

During the spring semester of my senior year I decided to build a chess engine for fun from the ground up in Java which you can view on my Github profile. The chess program AI contains practical implementations of various concepts from topics such as data structures and algorithms and exemplifies tradeoffs between memory usage, computation time, AI skill (heuristic complexity), and code complexity. The GUI sits on top of a massive, dynamically generated tree/uni-directional-graph of nodes which contain chess board configurations and other characteristics. When generating an AI player move, the alpha-beta pruning algorithm extends the tree using iterative deepening and a fail-soft quiescence search with an original heuristic scoring each terminal node. Possible moves are generated by referencing a transposition table: a hashmap of every possible combination of pieces, locations, and moves. Previously searched nodes are stored in a hashmap with keys constructed by xoring unique 64 bit longs that correspond to each piece on each square. This algorithm is capable of searching millions of nodes and filling gigabytes of ram in seconds in order to find an optimal move. I also worked with a team of mechanical engineers on their senior design project to help modify the chess engine so that the GUI input and AI would relay instructions to a controller via Visual Basic in order to manipulate pieces on a physical chess board using a delta robot. 

